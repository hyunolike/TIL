## 디자인 패턴
- 생성패턴, 구조패턴, 행위패턴
- 소프트웨어 공학론 안의 좋은 코드를 설계하기 위한 일종으 설계 방법론
- 프로그래머들이 유용하다고 생각되는 __객체들간의 일반적인 상호작용 방법__ 들을 모은 목록

### 생성패턴
- 객체 인스턴스 생성을 위한 클래스 정의와 객체 생성 방식의 구조화 캡슐화 방법 등 제공
    - `Fatory method` : 객체를 생성하는 일을 __서브 클래스__ 가 담당
    - `Singleton` : 지정한 클래스의 인스턴스가 반드시 1개만 존재
    - `Abstract factory` : 관련성을 갖는 객체들의 집합을 생성, 서로 독립적인 
    객체들의 집합을 생성 -> 인터페이스 제공
    - `Builder` : 원본이 되는 인스턴스를 사용해 생성할 객체의 종류 명시, 견본을 복사
    해서 새로운 객체를 생성
      
### 구조패턴
- 다른 기능을 가진 객체 간에 협력 필요할때 조직화, 기능 구현 객체 구성 방법
    - `Adapter` : 클래스의 재사용성을 높이기 위해  클래스간의 기능을 변환 제공 -> 호환성 확보
    - `Bridge` : API가 서로 다른 클래스를 연결할 때 기능,구현 계층을 연결
    - `Composite` : 복잡한 객체 구조를 표현 -> 객체 집합 속에 또 다른 객체 집합
    - `Decorator` : 새로은 기능을 추가될 때마다 새로운 객체, 이전 객체의 기능은 
    새로운 객체 내부에서도 그대로 유지, 보장
    - `Facade` : 서브 시스템이 복잡할 경우 간단한 인터페이스를 통해 서브 클래스의 주요기능을 사용
    - `Fly weight` : 인스턴스를 가능한 한 공유 -> 불필요한 생성 하지 않게 함
    - `Proxy` : 객체 접근 제어하려는 목적, 인터페이스 역할을 하는 객체(Proxy Object) 사용

### 행위패턴 
- 객체 간의 연동에 대한 유형 제공
    - `Template method` : 상위 클래스에서 처리의 흐름, 하위 클래스에서 구체적인 내용 재정의
    - `Interpreter ` : 간단한 언어의 문법을 정의, 그 언어로 문장 구성, 문장 해석 방법
    - `Iterator` : 집합 객체 요소들의 표현 방식 공개x ,순차적으로 접근하는 구조 제공
    - `Command` : 요청자체 -> 캡슐화, 매개변수 추가하여 여러가지 요구사항 추가
    - `Chain of Responsibility` : 요청 처리 기회 -> 하나 이상의 객체에 부여, 객체 간의 결합도 없애는 패턴
    - `State` : 객체 -> 상태에 따른 행동들을 분리
    - `Strategy` : 상황에 맞게 알고리즘 변경 필요 -> 공통된 인터페이스에 맞게 구현하여 다형성 활용
    - `Mediator` : 중재자 -> 한 집합에 속해있는 객체들의 상호작용 -> 캡슐화 
    - `Mememto` : 어떤 시점에서의 객체 상태를 저장 -> 필요 시 객체를 그 시점의 상태로 되돌리는 패턴
    - `Visitor` : 데이터 구조 안을 돌아다니는 주체인 `방문자` 클래스 준비 -> 기능 추가 시 유연성 제공
    - `Observer` : 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에게 통지 -> 자동으로 내용 갱신


